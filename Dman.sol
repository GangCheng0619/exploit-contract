// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRC20.sol";

library SafeMath {

	function add(uint a, uint b) internal pure returns (uint) {
		uint c = a + b;
		require(c >= a, "SafeMath: addition overflow");

		return c;
	}

	function sub(uint a, uint b) internal pure returns (uint) {
		return sub(a, b, "SafeMath: subtraction overflow");
	}

	function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
		require(b <= a, errorMessage);
		uint c = a - b;

		return c;
	}

	function mul(uint a, uint b) internal pure returns (uint) {
		
		if (a == 0) {
			return 0;
		}

		uint c = a * b;
		require(c / a == b, "SafeMath: multiplication overflow");

		return c;
	}

	function div(uint a, uint b) internal pure returns (uint) {
		return div(a, b, "SafeMath: division by zero");
	}

	function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
		// Solidity only automatically asserts when dividing by 0
		require(b > 0, errorMessage);
		uint c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold

		return c;
	}

	function mod(uint a, uint b) internal pure returns (uint) {
		return mod(a, b, "SafeMath: modulo by zero");
	}

	function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
		require(b != 0, errorMessage);
		return a % b;
	}
}

contract Dman is IRC20("DMan", "DM", 18, 1e9 * 1e18) {
    using SafeMath for uint;

    uint startTime;
    uint endTime;

    uint ONE = 1e18;

    address USDT = 0x000000;
    uint USDTDecimals = 18;

    address fAddress;
    uint flockedAmount = 3 * 1e7 * ON;

    uint presalePrice = 5 * 10 ** (USDTDecimals - 3);
    mapping(address=>uint) presales;

    constructor(address _bossAddress, address _fAddress) {
        startTime = block.timestamp;
        endTime = startTime + 30 days;

        _mint(_bossAddress, 2 * 1e7 * ONE);
        fAddress = _fAddress;
        _mint(_fAddress, flockedAmount);
        
    }
	
    function presale(uint amountUSDT) public {
        address _from = msg.sender;
        uint time = block.timestamp;
        uint _totalPresale = presales[_from] + amountUSDT;
        IRC20(USDT).transferFrom(_from, address(this), amountUSDT);
        uint _quantity = amountUSDT * ONE / presalePrice
        _mint(_from, _quantity);
        presales[_from] = _totalPresale;
        
        require(time <= endTime, "exceed presale time");
        require(amountUSDT >= 200 * 10 ** USDTDecimals, "min 200U");
        require(_totalPresale <= 3000 * 10 ** USDTDecimals, "total than less 3000U");
    }

    function transfer(address recipient, uint256 amount) public  returns (bool) {
        uint time = block.timestamp;

        if (msg.sender==fAddress) {
            if (time <= startTime + 365 days) {
                uint _balance = balanceOf(fAddress).sub(amount);
                require(_balance < flockedAmount, "locked amount"); 
            }
        }
        _transfer(msg.sender, recipient, amount);
        return true;
    }
}